# 上下文调度策略

## 概述

上下文调度策略是代码审查系统的核心创新点，解决了传统代码审查工具面临的"上下文不足"和"信息噪音"两大难题。通过**规则+LLM融合**的策略，系统能够为每个变更单元精准调度所需的上下文信息。

### 核心问题

传统代码审查工具面临的困境：

```
方案1：仅提供diff → 上下文不足，无法理解变更影响
方案2：提供完整文件 → 信息噪音，淹没关键变更
方案3：固定窗口 → 一刀切，无法适应不同场景
```

### 本系统的解决方案

```
┌─────────────────────────────────────────────────────────────────┐
│                    精准上下文调度                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  规则层快速分析 → 置信度量化 → LLM智能规划 → 融合决策 → 动态调度  │
│                                                                  │
│  • 毫秒级规则匹配                                                 │
│  • 置信度驱动融合                                                 │
│  • 分层上下文策略                                                 │
│  • 动态额外请求                                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 上下文问题分析

### 传统方案的局限

#### 1. 仅Diff方案

```python
# 问题：缺少函数签名和上下文
@@ -10,3 +10,5 @@
-    return user.name
+    if user.is_active:
+        return user.name
+    return None
```

审查者无法知道：
- 函数名称和参数
- 返回值类型
- 调用方如何处理None

#### 2. 完整文件方案

```python
# 问题：1000行文件，只改了3行
# LLM需要处理大量无关代码
# 关键变更被淹没在噪音中
```

#### 3. 固定窗口方案

```python
# 问题：窗口大小难以确定
# 小改动浪费token
# 大改动上下文不足
```

### 理想的上下文策略

不同类型的变更需要不同级别的上下文：

| 变更类型 | 所需上下文 | 示例 |
|---------|-----------|------|
| 注释修改 | 仅diff | 修正拼写错误 |
| 函数内逻辑 | diff + 函数 | 添加参数校验 |
| 公共API变更 | diff + 文件 + 调用方 | 修改函数签名 |
| 配置文件 | diff + 完整文件 | 修改路由配置 |

## JSON+Markdown混合格式设计

### 设计理念

系统采用**JSON元数据 + Markdown内容**的混合格式作为LLM输入：

```
为什么不用纯JSON？
- 代码片段在JSON中需要转义，可读性差
- LLM对Markdown格式的代码理解更好

为什么不用纯Markdown？
- 缺少结构化元数据
- 难以程序化处理和验证

混合格式的优势：
- JSON提供结构化元数据（文件路径、行号、标签）
- Markdown提供可读的代码内容
- 兼顾机器处理和LLM理解
```

### 数据结构

#### planner_index（规划阶段输入）

```json
{
  "review_metadata": {
    "mode": "staged|working|pr",
    "base_branch": "...",
    "total_files": 2,
    "total_changes": 5,
    "timestamp": "..."
  },
  "summary": {
    "changes_by_type": {"add": 0, "modify": 2, "delete": 0},
    "total_lines": {"added": 12, "removed": 3},
    "files_changed": ["src/auth.py", "src/models.py"]
  },
  "units": [
    {
      "unit_id": "unit_abc123",
      "file_path": "src/auth.py",
      "patch_type": "modify",
      "tags": ["function_change", "api_endpoint"],
      "metrics": {"added_lines": 10, "removed_lines": 2, "hunk_count": 1},
      "rule_context_level": "function",
      "rule_confidence": 0.85,
      "line_numbers": {"new_compact": "L10-L25", "old_compact": "L10-L22"},
      "rule_extra_requests": [{"type": "previous_version"}]
    }
  ]
}
```

说明：规划阶段输入使用 `planner_index`（轻量索引），不包含 diff 正文、`rule_notes`、`rule_suggestion` 等大字段。

#### ContextBundle（审查阶段输入）

```json
{
  "unit_id": "unit_abc123",
  "meta": {
    "file_path": "src/auth.py",
    "location": "src/auth.py:L10-L25",
    "tags": ["function_change", "api_endpoint"]
  },
  "final_context_level": "function",
  "extra_requests": [{"type": "previous_version"}],
  "diff": "@@ src/auth.py:L10-L25 @@\n...",
  "function_context": "def authenticate(username, password):\n    ...",
  "file_context": null,
  "full_file": null,
  "previous_version": null,
  "callers": []
}
```

## 融合策略

### 融合流程

```
┌─────────────────────────────────────────────────────────────────┐
│                         融合决策流程                              │
└─────────────────────────────────────────────────────────────────┘

  规则建议                    LLM规划
  (rule_context_level)       (llm_context_level)
  (rule_confidence)          (extra_requests)
       │                           │
       └───────────┬───────────────┘
                   ▼
          ┌─────────────────┐
          │  置信度判断      │
          └─────────────────┘
                   │
       ┌───────────┼───────────┐
       ▼           ▼           ▼
   高置信度     中等置信度    低置信度
   (≥0.8)      (0.3-0.8)     (<0.3)
       │           │           │
       ▼           ▼           ▼
   规则优先    综合决策     LLM优先
       │           │           │
       └───────────┼───────────┘
                   ▼
          ┌─────────────────┐
          │ final_context   │
          │     _level      │
          └─────────────────┘
```

### 置信度驱动的融合逻辑

```python
# Agent/agents/fusion.py

# 置信度阈值
T_HIGH = 0.8    # 规则建议为权威来源
T_MEDIUM = 0.5  # 中等置信度
T_LOW = 0.3     # 优先采用LLM建议

def fuse_plan(review_index, llm_plan):
    """融合规则层与LLM规划"""
    
    for unit in units:
        rule_level = unit["rule_context_level"]
        rule_conf = unit["rule_confidence"]
        llm_level = llm_plan.get(unit_id, {}).get("llm_context_level")
        
        # 高置信度：规则建议为主，但允许LLM升级
        if rule_conf >= T_HIGH:
            final_level = llm_level if ctx_rank(llm_level) > ctx_rank(rule_level) else rule_level
        
        # 低置信度：LLM建议为主
        elif rule_conf <= T_LOW:
            final_level = llm_level or rule_level
        
        # 中等置信度：根据上下文级别优先级决定
        else:
            if ctx_rank(llm_level) > ctx_rank(rule_level):
                final_level = llm_level
            else:
                final_level = rule_level
```

### 上下文级别优先级

```python
# Agent/DIFF/rule/context_levels.py

CONTEXT_LEVELS = {
    "diff_only": 0,      # 最小上下文
    "function": 1,       # 函数级
    "file_context": 2,   # 文件上下文
    "full_file": 3       # 完整文件
}

def ctx_rank(level: str) -> int:
    """返回上下文级别的优先级"""
    return CONTEXT_LEVELS.get(level, 0)
```

### 高风险变更保护

```python
# 高风险变更不可跳过审查
HIGH_RISK_TAGS = {"security_sensitive", "config_file", "routing_file"}

def _is_high_risk(unit):
    # 1. 高置信度
    if unit["rule_confidence"] >= 0.8:
        return True
    
    # 2. 高风险标签
    if HIGH_RISK_TAGS.intersection(unit["tags"]):
        return True
    
    # 3. notes中的风险等级
    if "high_risk" in unit["rule_notes"]:
        return True
    
    return False

# 融合时强制保留高风险单元
if _is_high_risk(unit) and skip_review:
    skip_review = False
    reason = "high_risk_cannot_skip"
```

## 上下文分层

### 四层上下文策略

系统采用统一的四级上下文：`diff_only` / `function` / `file_context` / `full_file`。

| 上下文级别 | 包含字段 | 适用场景 |
|----------|----------|----------|
| `diff_only` | `diff` | 极小改动、低风险变更、仅需关注差异 |
| `function` | `diff` + `function_context` | 函数内逻辑修改，需要看到函数签名/局部上下文 |
| `file_context` | `diff` + `file_context` | 影响跨函数/类的改动，需要文件局部窗口 |
| `full_file` | `diff` + `full_file` | 配置/路由/安全敏感或文件结构强相关的变更 |

补充说明：
- `diff` 字段会始终包含（带位置标头并按长度截断）。
- `full_file` 会在文件过大时做 head/mid/tail 截断以控制体积。
- 如需额外上下文，可通过 `extra_requests` 请求（PlanningAgent 当前使用 `details` 字段传参）：
  - `previous_version`：无需额外字段（当前版本可稳定生效）
  - `callers`：PlanningAgent 输出 `details`，ContextScheduler 读取 `symbol`（未映射时会跳过）
  - `search`：PlanningAgent 输出 `details`，ContextScheduler 读取 `keyword`/`text`（未映射时会跳过）
  - 规则侧还可能产生 `search_callers/search_config_usage/search_implementations/search_model_usage/search_class_methods` 等类型，目前调度器未接通

