# 自我学习机制

## 概述

自我学习机制是代码审查内核的核心创新之一，通过追踪规则层与LLM决策之间的冲突，自动提取可复用的规则模式，实现规则库的持续增长。

### 设计理念

```
传统方案：规则库静态维护 → 覆盖率有限，难以适应新场景
本系统：冲突追踪 + 模式提取 → 规则自动增长，持续优化
```

自我学习的核心价值：
- **冲突即信号**：规则与LLM的分歧揭示了规则的不足
- **数据驱动**：基于真实审查数据提取规则，而非人工编写
- **闭环优化**：从冲突到规则的完整闭环，持续提升准确率
- **可控增长**：严格的提取条件确保规则质量

## 架构

```
┌─────────────────────────────────────────────────────────────────┐
│                       自我学习机制                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   冲突追踪层                              │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │   │
│  │  │ConflictTracker│ │RuleConflict │ │ConflictType │     │   │
│  │  │  (追踪器)    │  │  (记录)     │  │  (类型)     │     │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   规则分析层                              │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │   │
│  │  │RuleAnalyzer │  │ApplicableRule│ │ReferenceHint│     │   │
│  │  │  (分析器)   │  │ (可应用规则) │  │ (参考提示)  │     │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   规则管理层                              │   │
│  │  ┌─────────────────┐  ┌─────────────────┐               │   │
│  │  │RuleConfigManager│  │ learned_rules.json│              │   │
│  │  │   (管理器)      │  │   (存储)         │              │   │
│  │  └─────────────────┘  └─────────────────┘               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │   RuleGrowthAPI │
                    │   (对外接口)     │
                    └─────────────────┘
```

## 冲突追踪设计

### 冲突类型

系统定义了四种冲突类型，每种类型代表不同的优化方向：

| 类型 | 说明 | 优化方向 |
|------|------|----------|
| `rule_high_llm_expand` | 规则高置信度建议较小上下文，LLM要求更多 | 规则可能低估了变更复杂度 |
| `rule_high_llm_skip` | 规则高置信度认为需要审查，LLM建议跳过 | 规则可能高估了变更风险 |
| `rule_low_llm_consistent` | 规则低置信度，LLM给出明确决策 | 可提取新规则 |
| `context_level_mismatch` | 中等置信度，上下文级别差异超过1级 | 置信度计算需要调整 |

```python
class ConflictType(Enum):
    RULE_HIGH_LLM_EXPAND = "rule_high_llm_expand"
    RULE_HIGH_LLM_SKIP = "rule_high_llm_skip"
    RULE_LOW_LLM_CONSISTENT = "rule_low_llm_consistent"
    CONTEXT_LEVEL_MISMATCH = "context_level_mismatch"
```

### 冲突检测逻辑

冲突检测发生在融合决策阶段，当规则建议与LLM决策存在显著差异时触发：

```python
def detect_conflict(unit, llm_decision) -> Optional[RuleConflict]:
    rule_confidence = unit.get("rule_confidence", 0.0)
    rule_level = unit.get("rule_context_level", "function")
    llm_level = llm_decision.get("llm_context_level")
    llm_skip = llm_decision.get("skip_review", False)
    
    # 场景1: 规则高置信度，LLM要求更多上下文
    if rule_confidence >= 0.8:
        if get_context_rank(llm_level) > get_context_rank(rule_level):
            return ConflictType.RULE_HIGH_LLM_EXPAND
        
        # 场景2: 规则高置信度，LLM建议跳过
        if llm_skip and rule_level not in ("diff_only", "local"):
            return ConflictType.RULE_HIGH_LLM_SKIP
    
    # 场景3: 规则低置信度，LLM给出明确决策
    elif rule_confidence < 0.3:
        if llm_level and get_context_rank(llm_level) >= 0:
            return ConflictType.RULE_LOW_LLM_CONSISTENT
    
    # 场景4: 中等置信度，上下文级别差异超过1级
    else:
        if abs(get_context_rank(llm_level) - get_context_rank(rule_level)) > 1:
            return ConflictType.CONTEXT_LEVEL_MISMATCH
    
    return None
```

### RuleConflict 记录结构

每个冲突记录包含完整的上下文信息，便于后续分析：

```python
@dataclass
class RuleConflict:
    conflict_type: ConflictType    # 冲突类型
    unit_id: str                   # 变更单元ID
    file_path: str                 # 文件路径
    language: str                  # 编程语言
    tags: List[str]                # 变更标签
    metrics: Dict[str, Any]        # 变更度量
    
    # 规则决策
    rule_context_level: str        # 规则建议的上下文级别
    rule_confidence: float         # 规则置信度
    rule_notes: str                # 规则匹配说明
    
    # LLM决策
    llm_context_level: str         # LLM建议的上下文级别
    llm_skip_review: bool          # LLM是否建议跳过
    llm_reason: str                # LLM决策理由
    
    # 元数据
    timestamp: str                 # 记录时间
    symbol_info: Dict[str, Any]    # 符号信息
```

### 冲突存储

冲突记录以JSON文件形式存储在 `Agent/DIFF/issue/conflicts/` 目录：

```
conflicts/
├── 20251206_143815_123456_rule_high_llm_expand.json
├── 20251206_143820_234567_rule_low_llm_consistent.json
└── ...
```

文件命名格式：`{timestamp}_{conflict_type}.json`



## 规则提取算法

### 语义特征分组

规则提取的第一步是按语义特征对冲突进行分组。与传统的基于文件路径分组不同，本系统采用**语义特征键**进行分组，确保提取的规则具有跨项目通用性：

```python
@dataclass(frozen=True)
class SemanticFeatureKey:
    language: str           # 编程语言
    tags_signature: str     # 排序后的标签签名，如 "api_endpoint|function_change"
    conflict_type: str      # 冲突类型
    
    @classmethod
    def from_conflict(cls, conflict: RuleConflict):
        sorted_tags = sorted(conflict.tags)
        return cls(
            language=conflict.language,
            tags_signature="|".join(sorted_tags),
            conflict_type=conflict.conflict_type.value,
        )
```

分组示例：

```
SemanticFeatureKey(
    language="python",
    tags_signature="api_endpoint|function_change|security_sensitive",
    conflict_type="rule_low_llm_consistent"
)
```

### 通用标签提取

从冲突组中提取出现在80%以上冲突中的通用标签：

```python
def extract_common_tags(conflicts: List[RuleConflict]) -> List[str]:
    """提取出现在80%+冲突中的通用标签"""
    if not conflicts:
        return []
    
    tag_counts = Counter()
    for conflict in conflicts:
        for tag in set(conflict.tags):
            tag_counts[tag] += 1
    
    threshold = len(conflicts) * 0.8  # 80%阈值
    common_tags = [
        tag for tag, count in tag_counts.items()
        if count >= threshold
    ]
    
    return sorted(common_tags)
```

### 一致性计算

计算LLM决策的一致性，即最常见决策占总决策的比例：

```python
def calculate_consistency(conflicts: List[RuleConflict]) -> Tuple[float, str]:
    """计算LLM决策一致性"""
    decisions = [c.llm_context_level for c in conflicts if c.llm_context_level]
    
    if not decisions:
        return 0.0, None
    
    decision_counts = Counter(decisions)
    most_common, count = decision_counts.most_common(1)[0]
    
    consistency = count / len(decisions)
    return consistency, most_common
```

### 可应用规则条件

只有满足以下**全部条件**的冲突组才能生成可应用规则：

| 条件 | 阈值 | 说明 |
|------|------|------|
| 最少出现次数 | ≥ 5 | 确保样本充足 |
| 最低一致性 | ≥ 90% | 确保LLM决策稳定 |
| 最少通用标签 | ≥ 2 | 确保规则有明确的触发条件 |
| 最少不同文件 | ≥ 2 | 确保规则不是针对单一文件 |

```python
class RuleAnalyzer:
    MIN_OCCURRENCES = 5          # 最少出现次数
    MIN_CONSISTENCY = 0.9        # 最低一致性 (90%)
    MIN_COMMON_TAGS = 2          # 最少通用标签数
    MIN_UNIQUE_FILES = 2         # 最少不同文件数
    TAG_PRESENCE_THRESHOLD = 0.8 # 标签出现阈值 (80%)
```

### ApplicableRule 结构

满足条件的冲突组会生成可应用规则：

```python
@dataclass
class ApplicableRule:
    rule_id: str                      # 唯一标识
    language: str                     # 编程语言
    required_tags: List[str]          # 必需的标签组合
    suggested_context_level: str      # 建议的上下文级别
    confidence: float                 # 置信度
    sample_count: int                 # 样本数量
    consistency: float                # 一致性比例
    unique_files: int                 # 不同文件数
    conflict_type: str                # 原始冲突类型
```

规则ID生成算法：

```python
def generate_rule_id(language: str, tags: List[str], conflict_type: str) -> str:
    content = f"{language}:{'+'.join(sorted(tags))}:{conflict_type}"
    hash_suffix = hashlib.md5(content.encode()).hexdigest()[:8]
    return f"rule_{language}_{hash_suffix}"
```

### ReferenceHint 结构

不满足自动应用条件的冲突组会生成参考提示，供开发者手动评估：

```python
@dataclass
class ReferenceHint:
    language: str                     # 编程语言
    tags: List[str]                   # 相关标签
    suggested_context_level: str      # 建议的上下文级别
    sample_count: int                 # 样本数量
    consistency: float                # 一致性比例
    reason: str                       # 不能自动应用的原因
    conflict_type: str                # 原始冲突类型
    unique_files: int                 # 不同文件数
    conflicts: List[Dict]             # 样本冲突摘要
```

不满足条件的原因示例：
- `样本不足 (3 < 5)`
- `一致性不足 (75% < 90%)`
- `通用标签不足 (1 < 2)`
- `文件覆盖不足 (1 < 2)`

## 可应用规则与参考提示的区分

### 区分标准

```
┌─────────────────────────────────────────────────────────────────┐
│                        冲突分析结果                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  满足全部条件？                                                  │
│  ├── 出现次数 ≥ 5                                               │
│  ├── 一致性 ≥ 90%                                               │
│  ├── 通用标签 ≥ 2                                               │
│  └── 不同文件 ≥ 2                                               │
│                                                                  │
│         │                                                        │
│    ┌────┴────┐                                                  │
│    ▼         ▼                                                  │
│  ┌─────┐  ┌─────────┐                                          │
│  │ 是  │  │   否    │                                          │
│  └──┬──┘  └────┬────┘                                          │
│     │          │                                                 │
│     ▼          ▼                                                 │
│ ┌────────────┐ ┌────────────┐                                   │
│ │ApplicableRule│ │ReferenceHint│                                │
│ │ 可一键应用  │ │ 仅供参考   │                                   │
│ └────────────┘ └────────────┘                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 设计考量

**为什么需要严格条件？**

1. **避免过拟合**：样本不足时，规则可能只适用于特定场景
2. **确保稳定性**：一致性不足说明LLM决策不稳定，规则可能不可靠
3. **保证通用性**：单一文件的规则可能是特例，不具备通用价值
4. **明确触发条件**：标签不足的规则难以精确匹配

**为什么保留参考提示？**

1. **信息不丢失**：即使不满足自动应用条件，冲突信息仍有参考价值
2. **人工评估**：开发者可以根据参考提示手动创建规则
3. **趋势观察**：参考提示的积累可能最终满足自动应用条件
4. **手动提升**：开发者可以将参考提示手动提升为规则



## 增长闭环流程

### 完整流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                       规则增长闭环                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────┐                                                    │
│  │代码审查  │                                                    │
│  └────┬────┘                                                    │
│       │                                                          │
│       ▼                                                          │
│  ┌─────────────────────────────────────────────────────┐       │
│  │              融合决策阶段                             │       │
│  │  规则建议 ←──比较──→ LLM决策                         │       │
│  └─────────────────────────────────────────────────────┘       │
│       │                                                          │
│       │ 检测到冲突                                               │
│       ▼                                                          │
│  ┌─────────────────────────────────────────────────────┐       │
│  │              冲突追踪                                 │       │
│  │  ConflictTracker.detect_and_record()                │       │
│  └─────────────────────────────────────────────────────┘       │
│       │                                                          │
│       │ 持久化存储                                               │
│       ▼                                                          │
│  ┌─────────────────────────────────────────────────────┐       │
│  │              冲突存储                                 │       │
│  │  conflicts/*.json                                    │       │
│  └─────────────────────────────────────────────────────┘       │
│       │                                                          │
│       │ 定期分析                                                 │
│       ▼                                                          │
│  ┌─────────────────────────────────────────────────────┐       │
│  │              规则分析                                 │       │
│  │  RuleAnalyzer.analyze_all()                         │       │
│  │  ├── 语义特征分组                                    │       │
│  │  ├── 通用标签提取                                    │       │
│  │  ├── 一致性计算                                      │       │
│  │  └── 条件评估                                        │       │
│  └─────────────────────────────────────────────────────┘       │
│       │                                                          │
│       ├──────────────────┬──────────────────┐                   │
│       ▼                  ▼                  ▼                   │
│  ┌──────────┐      ┌──────────┐      ┌──────────┐              │
│  │可应用规则 │      │参考提示  │      │ 无结果   │              │
│  └────┬─────┘      └────┬─────┘      └──────────┘              │
│       │                  │                                       │
│       │ 一键应用         │ 手动评估                              │
│       ▼                  ▼                                       │
│  ┌─────────────────────────────────────────────────────┐       │
│  │              规则配置                                 │       │
│  │  RuleConfigManager.add_tag_rule()                   │       │
│  │  learned_rules.json                                  │       │
│  └─────────────────────────────────────────────────────┘       │
│       │                                                          │
│       │ 规则生效                                                 │
│       ▼                                                          │
│  ┌─────────────────────────────────────────────────────┐       │
│  │              规则匹配                                 │       │
│  │  RuleHandler.match() 使用新规则                      │       │
│  └─────────────────────────────────────────────────────┘       │
│       │                                                          │
│       └──────────────────────────────────────────────────┐      │
│                                                          │      │
│                                                          ▼      │
│                                              ┌─────────┐        │
│                                              │代码审查  │        │
│                                              └─────────┘        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 阶段详解

#### 阶段1：冲突检测

在融合决策阶段，系统比较规则建议与LLM决策：

```python
# 融合决策时检测冲突
conflict = tracker.detect_conflict(unit, llm_decision)
if conflict:
    tracker.record(conflict)
```

#### 阶段2：冲突存储

冲突记录持久化到文件系统，支持：
- 按时间清理旧记录
- 按数量限制存储
- 标记已提升的冲突

```python
# 清理30天前的记录，最多保留1000条
tracker.cleanup_old_conflicts(max_age_days=30, max_count=1000)
```

#### 阶段3：规则分析

定期或按需分析冲突，生成规则建议：

```python
analyzer = RuleAnalyzer()
applicable_rules, reference_hints = analyzer.analyze_all()
```

#### 阶段4：规则应用

可应用规则可以一键应用到配置：

```python
# 应用规则
manager = RuleConfigManager()
manager.add_tag_rule(rule.language, rule)

# 标记相关冲突为已提升
tracker.mark_conflicts_as_promoted(
    language=rule.language,
    tags=rule.required_tags,
    conflict_type=rule.conflict_type,
    rule_id=rule.rule_id
)
```

#### 阶段5：规则生效

新规则存储在 `learned_rules.json`，在规则匹配时被加载：

```json
{
  "version": "1.0",
  "rules": {
    "python": [
      {
        "required_tags": ["api_endpoint", "security_sensitive"],
        "context_level": "file_context",
        "base_confidence": 0.92,
        "notes": "learned:api_endpoint+security_sensitive",
        "source": "conflict_learning",
        "rule_id": "rule_python_a1b2c3d4",
        "learned_at": "2025-12-06T14:38:15",
        "sample_count": 8,
        "consistency": 0.95
      }
    ]
  },
  "updated_at": "2025-12-06T14:38:15"
}
```

### 手动提升流程

对于不满足自动应用条件的参考提示，开发者可以手动提升为规则：

```python
# 手动提升参考提示为规则
result = RuleGrowthAPI.promote_hint(
    language="python",
    tags=["api_endpoint", "function_change"],
    suggested_context_level="function",
    sample_count=3,
    consistency=0.75,
    conflict_type="rule_low_llm_consistent"
)
```

手动提升的规则会：
1. 使用较低的基础置信度，计算公式为 `min(0.85, consistency * 0.9)`，若无一致性数据则为 `0.7`
2. 保留原始冲突类型作为来源（若无则标记为 `manual_promotion`）
3. 将相关冲突标记为已提升

## API接口

### RuleGrowthAPI

系统提供统一的API接口，支持以下操作：

| 方法 | 说明 |
|------|------|
| `get_summary()` | 获取冲突汇总统计 |
| `get_trend_analysis(days)` | 获取冲突趋势分析 |
| `get_rule_suggestions()` | 生成规则优化建议 |
| `get_enhanced_suggestions()` | 获取可应用规则和参考提示 |
| `apply_rule(rule_id)` | 应用规则到配置 |
| `promote_hint(...)` | 手动提升参考提示为规则 |
| `get_learned_rules()` | 获取所有学习到的规则 |
| `remove_learned_rule(rule_id)` | 移除学习到的规则 |
| `cleanup_old_conflicts(...)` | 清理旧的冲突记录 |
| `export_report(output_path)` | 导出完整分析报告 |

### 使用示例

```python
from Agent.core.api.rule_growth import RuleGrowthAPI

# 获取冲突汇总
summary = RuleGrowthAPI.get_summary()
print(f"总冲突数: {summary['total_conflicts']}")
print(f"按类型: {summary['by_type']}")

# 获取增强建议
suggestions = RuleGrowthAPI.get_enhanced_suggestions()
for rule in suggestions['applicable_rules']:
    print(f"可应用规则: {rule['rule_id']}")
    print(f"  语言: {rule['language']}")
    print(f"  标签: {rule['required_tags']}")
    print(f"  建议级别: {rule['suggested_context_level']}")
    print(f"  置信度: {rule['confidence']}")

# 应用规则
result = RuleGrowthAPI.apply_rule("rule_python_a1b2c3d4")
if result['success']:
    print("规则应用成功")
```

## 相关文档

- [架构设计](../核心文档/架构设计.md)：系统整体架构
- [规则解析系统](规则解析系统.md)：规则层设计详解
- [审查链路](审查链路.md)：完整的审查流程
- [上下文调度策略](上下文调度策略.md)：融合策略详解
